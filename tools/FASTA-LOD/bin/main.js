// Generated by Haxe 4.2.0
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var js_node_ChildProcess = require("child_process");
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
var Sys = function() { };
Sys.__name__ = true;
Sys.environment = function() {
	var m = new haxe_ds_StringMap();
	var _g = 0;
	var _g1 = Reflect.fields(process.env);
	while(_g < _g1.length) {
		var key = _g1[_g];
		++_g;
		var v = process.env[key];
		m.h[key] = v;
	}
	return m;
};
Sys.systemName = function() {
	var _g = process.platform;
	switch(_g) {
	case "darwin":
		return "Mac";
	case "freebsd":
		return "BSD";
	case "linux":
		return "Linux";
	case "win32":
		return "Windows";
	default:
		var other = _g;
		return other;
	}
};
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,matchedPos: function() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	,matchSub: function(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			var b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			var b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	,map: function(s,f) {
		var offset = 0;
		var buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			var p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
};
var Console = function() { };
Console.__name__ = true;
Console.format = function(s,formatMode) {
	s += "<//>";
	var activeFormatFlagStack = [];
	var groupedProceedingTags = [];
	var browserFormatArguments = [];
	var result = Console.formatTagPattern.map(s,function(e) {
		var escaped = e.matched(1) != null;
		if(escaped) {
			return e.matched(0);
		}
		var open = e.matched(2) == null;
		var tags = e.matched(3).split(",");
		if(!open && tags.length == 1) {
			if(tags[0] == "") {
				var last = activeFormatFlagStack[activeFormatFlagStack.length - 1];
				var i = activeFormatFlagStack.indexOf(last);
				if(i != -1) {
					var proceedingTags = groupedProceedingTags[i];
					activeFormatFlagStack.splice(i - proceedingTags,proceedingTags + 1);
					groupedProceedingTags.splice(i - proceedingTags,proceedingTags + 1);
				}
			} else if(FormatFlag.fromString(tags[0]) == "reset") {
				activeFormatFlagStack = [];
				groupedProceedingTags = [];
			} else {
				var flag = FormatFlag.fromString(tags[0]);
				if(flag != null) {
					var i = activeFormatFlagStack.indexOf(flag);
					if(i != -1) {
						var proceedingTags = groupedProceedingTags[i];
						activeFormatFlagStack.splice(i - proceedingTags,proceedingTags + 1);
						groupedProceedingTags.splice(i - proceedingTags,proceedingTags + 1);
					}
				}
			}
		} else {
			var proceedingTags = 0;
			var _g = 0;
			while(_g < tags.length) {
				var tag = tags[_g];
				++_g;
				var flag = FormatFlag.fromString(tag);
				if(flag == null) {
					return e.matched(0);
				}
				if(open) {
					activeFormatFlagStack.push(flag);
					groupedProceedingTags.push(proceedingTags);
					++proceedingTags;
				} else {
					var i = activeFormatFlagStack.indexOf(flag);
					if(i != -1) {
						var proceedingTags1 = groupedProceedingTags[i];
						activeFormatFlagStack.splice(i - proceedingTags1,proceedingTags1 + 1);
						groupedProceedingTags.splice(i - proceedingTags1,proceedingTags1 + 1);
					}
				}
			}
		}
		switch(formatMode) {
		case 0:
			if(open) {
				if(activeFormatFlagStack.length > 0) {
					var lastFlagCount = groupedProceedingTags[groupedProceedingTags.length - 1] + 1;
					var asciiFormatString = "";
					var _g = 0;
					var _g1 = lastFlagCount;
					while(_g < _g1) {
						var i = _g++;
						var idx = groupedProceedingTags.length - 1 - i;
						asciiFormatString += Console.getAsciiFormat(activeFormatFlagStack[idx]);
					}
					return asciiFormatString;
				} else {
					return "";
				}
			} else {
				var result = Console.getAsciiFormat("reset");
				var result1 = new Array(activeFormatFlagStack.length);
				var _g = 0;
				var _g1 = activeFormatFlagStack.length;
				while(_g < _g1) {
					var i = _g++;
					result1[i] = Console.getAsciiFormat(activeFormatFlagStack[i]);
				}
				var _g = [];
				var _g1 = 0;
				var _g2 = result1;
				while(_g1 < _g2.length) {
					var v = _g2[_g1];
					++_g1;
					if(v != null) {
						_g.push(v);
					}
				}
				return result + _g.join("");
			}
			break;
		case 1:
			var browserFormatArguments1 = browserFormatArguments;
			var result = new Array(activeFormatFlagStack.length);
			var _g = 0;
			var _g1 = activeFormatFlagStack.length;
			while(_g < _g1) {
				var i = _g++;
				result[i] = Console.getBrowserFormat(activeFormatFlagStack[i]);
			}
			var _g = [];
			var _g1 = 0;
			var _g2 = result;
			while(_g1 < _g2.length) {
				var v = _g2[_g1];
				++_g1;
				if(v != null) {
					_g.push(v);
				}
			}
			browserFormatArguments1.push(_g.join(";"));
			return "%c";
		case 2:
			return "";
		}
	});
	return { formatted : result, browserFormatArguments : browserFormatArguments};
};
Console.printFormatted = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	var result = Console.format(s,Console.formatMode);
	if(Console.formatMode == 1) {
		var logArgs = [result.formatted].concat(result.browserFormatArguments);
		switch(outputStream) {
		case 1:
			console.warn.apply(console, logArgs);
			break;
		case 2:
			console.error.apply(console, logArgs);
			break;
		case 0:case 3:
			console.log.apply(console, logArgs);
			break;
		}
		return;
	}
	Console.print(result.formatted,outputStream);
};
Console.print = function(s,outputStream) {
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	if(Console.printIntercept != null) {
		var allowDefaultPrint = Console.printIntercept(s,outputStream);
		if(!allowDefaultPrint) {
			return;
		}
	}
	if(Console.unicodeCompatibilityMode == 1 && !Console.unicodeCompatibilityEnabled) {
		Console.exec("chcp 65001");
		Console.unicodeCompatibilityEnabled = true;
	}
	switch(outputStream) {
	case 1:case 2:
		new _$Sys_FileOutput(2).writeString(s);
		break;
	case 0:case 3:
		new _$Sys_FileOutput(1).writeString(s);
		break;
	}
};
Console.getAsciiFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		var hex = HxOverrides.substr(flag,1,null);
		var r = Std.parseInt("0x" + HxOverrides.substr(hex,0,2));
		var g = Std.parseInt("0x" + HxOverrides.substr(hex,2,2));
		var b = Std.parseInt("0x" + HxOverrides.substr(hex,4,2));
		return "\x1B[38;5;" + Console.rgbToAscii256(r,g,b) + "m";
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		var hex = HxOverrides.substr(flag,3,null);
		var r = Std.parseInt("0x" + HxOverrides.substr(hex,0,2));
		var g = Std.parseInt("0x" + HxOverrides.substr(hex,2,2));
		var b = Std.parseInt("0x" + HxOverrides.substr(hex,4,2));
		return "\x1B[48;5;" + Console.rgbToAscii256(r,g,b) + "m";
	}
	switch(flag) {
	case "bg_black":
		return "\x1B[48;5;" + 0 + "m";
	case "bg_blue":
		return "\x1B[48;5;" + 4 + "m";
	case "bg_cyan":
		return "\x1B[48;5;" + 6 + "m";
	case "bg_green":
		return "\x1B[48;5;" + 2 + "m";
	case "bg_light_black":
		return "\x1B[48;5;" + 8 + "m";
	case "bg_light_blue":
		return "\x1B[48;5;" + 12 + "m";
	case "bg_light_cyan":
		return "\x1B[48;5;" + 14 + "m";
	case "bg_light_green":
		return "\x1B[48;5;" + 10 + "m";
	case "bg_light_magenta":
		return "\x1B[48;5;" + 13 + "m";
	case "bg_light_red":
		return "\x1B[48;5;" + 9 + "m";
	case "bg_light_white":
		return "\x1B[48;5;" + 15 + "m";
	case "bg_light_yellow":
		return "\x1B[48;5;" + 11 + "m";
	case "bg_magenta":
		return "\x1B[48;5;" + 5 + "m";
	case "bg_red":
		return "\x1B[48;5;" + 1 + "m";
	case "bg_white":
		return "\x1B[48;5;" + 7 + "m";
	case "bg_yellow":
		return "\x1B[48;5;" + 3 + "m";
	case "black":
		return "\x1B[38;5;" + 0 + "m";
	case "blink":
		return "\x1B[5m";
	case "blue":
		return "\x1B[38;5;" + 4 + "m";
	case "bold":
		return "\x1B[1m";
	case "cyan":
		return "\x1B[38;5;" + 6 + "m";
	case "dim":
		return "\x1B[2m";
	case "green":
		return "\x1B[38;5;" + 2 + "m";
	case "hidden":
		return "\x1B[8m";
	case "invert":
		return "\x1B[7m";
	case "italic":
		return "\x1B[3m";
	case "light_black":
		return "\x1B[38;5;" + 8 + "m";
	case "light_blue":
		return "\x1B[38;5;" + 12 + "m";
	case "light_cyan":
		return "\x1B[38;5;" + 14 + "m";
	case "light_green":
		return "\x1B[38;5;" + 10 + "m";
	case "light_magenta":
		return "\x1B[38;5;" + 13 + "m";
	case "light_red":
		return "\x1B[38;5;" + 9 + "m";
	case "light_white":
		return "\x1B[38;5;" + 15 + "m";
	case "light_yellow":
		return "\x1B[38;5;" + 11 + "m";
	case "magenta":
		return "\x1B[38;5;" + 5 + "m";
	case "red":
		return "\x1B[38;5;" + 1 + "m";
	case "reset":
		return "\x1B[m";
	case "underline":
		return "\x1B[4m";
	case "white":
		return "\x1B[38;5;" + 7 + "m";
	case "yellow":
		return "\x1B[38;5;" + 3 + "m";
	default:
		return "";
	}
};
Console.rgbToAscii256 = function(r,g,b) {
	var nearIdx = function(c,set) {
		var delta = Infinity;
		var index = -1;
		var _g = 0;
		var _g1 = set.length;
		while(_g < _g1) {
			var i = _g++;
			var d = Math.abs(c - set[i]);
			if(d < delta) {
				delta = d;
				index = i;
			}
		}
		return index;
	};
	var colorSteps = [0,95,135,175,215,255];
	var ir = nearIdx(r,colorSteps);
	var ig = nearIdx(g,colorSteps);
	var ib = nearIdx(b,colorSteps);
	var ier = Math.abs(r - colorSteps[ir]);
	var ieg = Math.abs(g - colorSteps[ig]);
	var ieb = Math.abs(b - colorSteps[ib]);
	var averageColorError = ier + ieg + ieb;
	var jr = Math.round((r - 8) / 10);
	var jg = Math.round((g - 8) / 10);
	var jb = Math.round((b - 8) / 10);
	var jer = Math.abs(r - Math.max(Math.min(jr * 10 + 8,238),8));
	var jeg = Math.abs(g - Math.max(Math.min(jg * 10 + 8,238),8));
	var jeb = Math.abs(b - Math.max(Math.min(jb * 10 + 8,238),8));
	var averageGrayError = jer + jeg + jeb;
	if(averageGrayError < averageColorError && r == g && g == b) {
		var grayIndex = jr + 232;
		return grayIndex;
	} else {
		var colorIndex = 16 + ir * 36 + ig * 6 + ib;
		return colorIndex;
	}
};
Console.getBrowserFormat = function(flag) {
	if(flag.charAt(0) == "#") {
		return "color: " + flag;
	}
	if(HxOverrides.substr(flag,0,3) == "bg#") {
		return "background-color: " + HxOverrides.substr(flag,2,null);
	}
	if(flag.charAt(0) == "{") {
		return HxOverrides.substr(flag,1,flag.length - 2);
	}
	switch(flag) {
	case "bg_black":
		return "background-color: black";
	case "bg_blue":
		return "background-color: blue";
	case "bg_cyan":
		return "background-color: cyan";
	case "bg_green":
		return "background-color: green";
	case "bg_light_black":
		return "background-color: gray";
	case "bg_light_blue":
		return "background-color: lightBlue";
	case "bg_light_cyan":
		return "background-color: lightCyan";
	case "bg_light_green":
		return "background-color: lightGreen";
	case "bg_light_magenta":
		return "background-color: lightPink";
	case "bg_light_red":
		return "background-color: salmon";
	case "bg_light_white":
		return "background-color: white";
	case "bg_light_yellow":
		return "background-color: lightYellow";
	case "bg_magenta":
		return "background-color: magenta";
	case "bg_red":
		return "background-color: red";
	case "bg_white":
		return "background-color: whiteSmoke";
	case "bg_yellow":
		return "background-color: gold";
	case "black":
		return "color: black";
	case "blink":
		return "text-decoration: blink";
	case "blue":
		return "color: blue";
	case "bold":
		return "font-weight: bold";
	case "cyan":
		return "color: cyan";
	case "dim":
		return "color: gray";
	case "green":
		return "color: green";
	case "hidden":
		return "visibility: hidden; color: white";
	case "invert":
		return "-webkit-filter: invert(100%); filter: invert(100%)";
	case "italic":
		return "font-style: italic";
	case "light_black":
		return "color: gray";
	case "light_blue":
		return "color: lightBlue";
	case "light_cyan":
		return "color: lightCyan";
	case "light_green":
		return "color: lightGreen";
	case "light_magenta":
		return "color: lightPink";
	case "light_red":
		return "color: salmon";
	case "light_white":
		return "color: white";
	case "light_yellow":
		return "color: #ffed88";
	case "magenta":
		return "color: magenta";
	case "red":
		return "color: red";
	case "reset":
		return "";
	case "underline":
		return "text-decoration: underline";
	case "white":
		return "color: whiteSmoke";
	case "yellow":
		return "color: #f5ba00";
	default:
		return "";
	}
};
Console.determineConsoleFormatMode = function() {
	var hasWindowObject = typeof(window) != "undefined";
	if(hasWindowObject) {
		return 1;
	}
	var tputColors = Console.exec("tput colors");
	if(tputColors.exit == 0) {
		var tputResult = Std.parseInt(tputColors.stdout);
		if(tputResult != null && tputResult > 2) {
			return 0;
		}
	}
	var termEnv = Sys.environment().h["TERM"];
	if(termEnv != null && new EReg("cygwin|xterm|vt100","").match(termEnv)) {
		return 0;
	}
	return 2;
};
Console.exec = function(cmd,args) {
	var p = js_node_ChildProcess.spawnSync(cmd,args != null ? args : [],{ });
	var stdout = p.stdout == null ? "" : p.stdout.toString();
	if(stdout == null) {
		stdout = "";
	}
	return { exit : p.status, stdout : stdout};
};
var FormatFlag = {};
FormatFlag.fromString = function(str) {
	str = str.toLowerCase();
	if(str.charAt(0) == "#" || HxOverrides.substr(str,0,3) == "bg#") {
		var hIdx = str.indexOf("#");
		var hex = HxOverrides.substr(str,hIdx + 1,null);
		if(hex.length == 3) {
			var a = hex.split("");
			hex = [a[0],a[0],a[1],a[1],a[2],a[2]].join("");
		}
		if(new EReg("[^0-9a-f]","i").match(hex) || hex.length < 6) {
			return "";
		}
		var normalized = str.substring(0,hIdx) + "#" + hex;
		return normalized;
	}
	switch(str) {
	case "!":
		return "invert";
	case "/":
		return "reset";
	case "b":
		return "bold";
	case "bg_gray":
		return "bg_light_black";
	case "gray":
		return "light_black";
	case "i":
		return "italic";
	case "u":
		return "underline";
	default:
		return str;
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.now = function() {
	return Date.now();
};
var Main = function() { };
Main.__name__ = true;
Main.convertFastaSequenceName = function(name) {
	if(Main.sequenceNameFilter != null) {
		Main.sequenceNameFilter.match(name);
		return "chr" + Main.sequenceNameFilter.matched(1) + ".bin";
	} else {
		return "" + name + ".bin";
	}
};
Main.main = function() {
	var args = process.argv.slice(2);
	if(args.length < 1) {
		var s = Console.errorPrefix + "Pass a fasta path and optional chromosome number as arguments";
		var outputStream = 2;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
		process.exit(1);
		return;
	}
	var fastaFilePath = args[0];
	var fastaFilename = haxe_io_Path.withoutExtension(haxe_io_Path.withoutDirectory(fastaFilePath));
	var chromosomeFilter = args[1] != null ? args[1] : "\\w+";
	var filter = "^(" + chromosomeFilter + ") dna:chromosome chromosome";
	if(args[1] != null) {
		var s = Console.logPrefix + ("" + Std.string("Filter is \"" + filter + "\""));
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
		Main.sequenceNameFilter = new EReg(filter,"");
	}
	var generatedFilePaths = Main.convertFastaFile(fastaFilePath,haxe_io_Path.join(["_output",fastaFilename + ".vdna-dir"]));
	var _g = 0;
	while(_g < generatedFilePaths.length) {
		var path = generatedFilePaths[_g];
		++_g;
		sys_FileSystem.createDirectory(haxe_io_Path.withoutExtension(path));
		Main.convertToUByte(path,haxe_io_Path.withoutExtension(path) + "/0.bin");
		var inputPath = path;
		var level = 1;
		var lastDoubleLodPath = null;
		while(true) {
			var outputPath = haxe_io_Path.withoutExtension(path) + ("-lod" + level + ".double");
			if(!Main.downsample(inputPath,outputPath)) {
				break;
			}
			Main.convertToUByte(outputPath,haxe_io_Path.withoutExtension(path) + ("/" + level + ".bin"));
			if(lastDoubleLodPath != null) {
				js_node_Fs.unlinkSync(lastDoubleLodPath);
			}
			lastDoubleLodPath = outputPath;
			inputPath = outputPath;
			++level;
		}
		if(lastDoubleLodPath != null) {
			js_node_Fs.unlinkSync(lastDoubleLodPath);
		}
	}
	var _g = 0;
	while(_g < generatedFilePaths.length) {
		var path = generatedFilePaths[_g];
		++_g;
		js_node_Fs.unlinkSync(path);
	}
};
Main.convertToUByte = function(path,outputPath,chunkSize_blocks) {
	if(chunkSize_blocks == null) {
		chunkSize_blocks = 20000000;
	}
	var s = Console.logPrefix + ("" + Std.string("<cyan>Converting to byte format \"<b>" + path + "</b>\"</cyan>"));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var range = Main.minMax(path);
	var delta = range.max - range.min;
	js_node_Fs.writeFileSync(outputPath + ".minmax",JSON.stringify(range));
	var acgtBlockSize = 32;
	var chunkSize_bytes = chunkSize_blocks * acgtBlockSize;
	var input = new sys_io_FileInput(js_node_Fs.openSync(path,"r"));
	var length_bytes = js_node_Fs.statSync(path).size;
	var chunksRequired = Math.ceil(UInt.toFloat(length_bytes) / UInt.toFloat(chunkSize_bytes));
	var output = new sys_io_FileOutput(js_node_Fs.openSync(outputPath,"w"));
	var _g = 0;
	var _g1 = chunksRequired;
	while(_g < _g1) {
		var chunk = _g++;
		var hrtime = process.hrtime();
		var t0 = hrtime[0] + hrtime[1] / 1e9;
		var bytesRemaining = length_bytes - chunk * chunkSize_bytes;
		var bytesToRead = Math.min(UInt.toFloat(bytesRemaining),UInt.toFloat(chunkSize_bytes)) | 0;
		var inputBytes = input.read(bytesToRead);
		var chunk_blocks = inputBytes.length / acgtBlockSize | 0;
		var outputBytes = new haxe_io_Bytes(new ArrayBuffer(chunk_blocks * 4));
		var _g2 = 0;
		var _g3 = chunk_blocks;
		while(_g2 < _g3) {
			var i = _g2++;
			var ip = i * acgtBlockSize;
			var a = inputBytes.getDouble(ip);
			var c = inputBytes.getDouble(ip + 8);
			var g = inputBytes.getDouble(ip + 16);
			var t = inputBytes.getDouble(ip + 24);
			var scaleFactor = delta == 0 ? 0 : 1 / delta;
			var op = i * 4;
			outputBytes.b[op] = Math.round(Math.min((a - range.min) * scaleFactor,1.) * 255);
			outputBytes.b[op + 1] = Math.round(Math.min((c - range.min) * scaleFactor,1.) * 255);
			outputBytes.b[op + 2] = Math.round(Math.min((g - range.min) * scaleFactor,1.) * 255);
			outputBytes.b[op + 3] = Math.round(Math.min((t - range.min) * scaleFactor,1.) * 255);
		}
		output.write(outputBytes);
		var hrtime1 = process.hrtime();
		var dt = hrtime1[0] + hrtime1[1] / 1e9 - t0;
		var progress = (chunk + 1) / chunksRequired;
		var s = Console.logPrefix + ("" + Std.string("<b>" + Math.round(progress * 100) + "%</b> (" + Math.round(bytesToRead / 1e6 / dt * 100) / 100 + " MB/s)"));
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
	}
	input.close();
	output.close();
	var s = Console.successPrefix + ("" + Std.string("<light_green>Saved \"<b>" + outputPath + "</b>\"<//>"));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
};
Main.minMax = function(path,chunkSize_blocks) {
	if(chunkSize_blocks == null) {
		chunkSize_blocks = 20000000;
	}
	var s = Console.logPrefix + ("" + Std.string("<cyan>Computing min/max of \"<b>" + path + "</b>\"</cyan>"));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var acgtBlockSize = 32;
	var chunkSize_bytes = chunkSize_blocks * acgtBlockSize;
	var input = new sys_io_FileInput(js_node_Fs.openSync(path,"r"));
	var length_bytes = js_node_Fs.statSync(path).size;
	var chunksRequired = Math.ceil(UInt.toFloat(length_bytes) / UInt.toFloat(chunkSize_bytes));
	var max = -Infinity;
	var min = Infinity;
	var _g = 0;
	var _g1 = chunksRequired;
	while(_g < _g1) {
		var chunk = _g++;
		var hrtime = process.hrtime();
		var t0 = hrtime[0] + hrtime[1] / 1e9;
		var bytesRemaining = length_bytes - chunk * chunkSize_bytes;
		var bytesToRead = Math.min(UInt.toFloat(bytesRemaining),UInt.toFloat(chunkSize_bytes)) | 0;
		var inputBytes = input.read(bytesToRead);
		var chunk_blocks = inputBytes.length / acgtBlockSize | 0;
		var _g2 = 0;
		var _g3 = chunk_blocks;
		while(_g2 < _g3) {
			var i = _g2++;
			var ip = i * acgtBlockSize;
			var a = inputBytes.getDouble(ip);
			var c = inputBytes.getDouble(ip + 8);
			var g = inputBytes.getDouble(ip + 16);
			var t = inputBytes.getDouble(ip + 24);
			var localMax = Math.max(Math.max(a,c),Math.max(g,t));
			var localMin = Math.min(Math.min(a,c),Math.min(g,t));
			max = Math.max(localMax,max);
			min = Math.min(localMin,min);
		}
		var hrtime1 = process.hrtime();
		var dt = hrtime1[0] + hrtime1[1] / 1e9 - t0;
		var progress = (chunk + 1) / chunksRequired;
		var s = Console.logPrefix + ("" + Std.string("<b>" + Math.round(progress * 100) + "%</b> (" + Math.round(bytesToRead / 1e6 / dt * 100) / 100 + " MB/s)"));
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
	}
	input.close();
	var s = Console.successPrefix + ("" + Std.string("min: " + min + ", max: " + max));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	return { min : min, max : max};
};
Main.downsample = function(path,outputPath,chunkSize_blocks) {
	if(chunkSize_blocks == null) {
		chunkSize_blocks = 20000000;
	}
	if((UInt.toFloat(chunkSize_blocks) % UInt.toFloat(2) | 0) != 0) {
		throw haxe_Exception.thrown("chunkSize_blocks must be multiple of 2");
	}
	var acgtBlockSize = 32;
	var chunkSize_bytes = chunkSize_blocks * acgtBlockSize;
	var s = Console.logPrefix + ("" + Std.string("<cyan>Downsampling \"<b>" + path + "</b>\"</cyan>"));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var input = new sys_io_FileInput(js_node_Fs.openSync(path,"r"));
	var length_bytes = js_node_Fs.statSync(path).size;
	var length_blocks = length_bytes / acgtBlockSize | 0;
	var chunksRequired = Math.ceil(UInt.toFloat(length_bytes) / UInt.toFloat(chunkSize_bytes));
	if(UInt.gte(1,length_blocks)) {
		input.close();
		return false;
	}
	var output_blocks = Math.ceil(UInt.toFloat(length_blocks) / UInt.toFloat(2));
	var output_bytes = output_blocks * acgtBlockSize;
	var s = Console.logPrefix + ("" + Std.string("\tacgtBlockSize: " + acgtBlockSize));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var s = Console.logPrefix + ("" + Std.string("\tchunkSize_bytes: " + (chunkSize_bytes == null ? "null" : Std.string(UInt.toFloat(chunkSize_bytes)))));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var s = Console.logPrefix + ("" + Std.string("\tchunksRequired: " + chunksRequired));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var s = Console.logPrefix + ("" + Std.string("\tlength_bytes: " + length_bytes));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var s = Console.logPrefix + ("" + Std.string("\tlength_blocks: " + (length_blocks == null ? "null" : Std.string(UInt.toFloat(length_blocks)))));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var s = Console.logPrefix + ("" + Std.string("\toutput_blocks: " + (output_blocks == null ? "null" : Std.string(UInt.toFloat(output_blocks)))));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var s = Console.logPrefix + ("" + Std.string("\toutput_bytes: " + (output_bytes == null ? "null" : Std.string(UInt.toFloat(output_bytes)))));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var output = new sys_io_FileOutput(js_node_Fs.openSync(outputPath,"w"));
	var s = Console.logPrefix + ("" + Std.string("Created \"<b>" + outputPath + "</b>\""));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var _g = 0;
	var _g1 = chunksRequired;
	while(_g < _g1) {
		var chunk = _g++;
		var hrtime = process.hrtime();
		var t0 = hrtime[0] + hrtime[1] / 1e9;
		var bytesRemaining = length_bytes - chunk * chunkSize_bytes;
		var bytesToRead = Math.min(UInt.toFloat(bytesRemaining),UInt.toFloat(chunkSize_bytes)) | 0;
		var inputBytes = input.read(bytesToRead);
		var chunk_blocks = inputBytes.length / acgtBlockSize | 0;
		var downsample_blocks = Math.ceil(UInt.toFloat(chunk_blocks) / UInt.toFloat(2));
		var downsampleBytes = new haxe_io_Bytes(new ArrayBuffer(downsample_blocks * acgtBlockSize));
		var _g2 = 0;
		var _g3 = downsample_blocks;
		while(_g2 < _g3) {
			var block = _g2++;
			var leftBlock = block * 2;
			var rightBlock = leftBlock + 1;
			if(UInt.gt(rightBlock,chunk_blocks - 1)) {
				rightBlock = chunk_blocks - 1;
				if(chunk != chunksRequired - 1) {
					var s = Console.errorPrefix + "Right sample overflowed chunk unexpectedly";
					var outputStream = 2;
					if(outputStream == null) {
						outputStream = 0;
					}
					if(s == null) {
						s = "";
					}
					Console.printFormatted(s + "\n",outputStream);
				}
			}
			var ipl = leftBlock * acgtBlockSize;
			var ipr = rightBlock * acgtBlockSize;
			var al = inputBytes.getDouble(ipl);
			var cl = inputBytes.getDouble(ipl + 8);
			var gl = inputBytes.getDouble(ipl + 16);
			var tl = inputBytes.getDouble(ipl + 24);
			var ar = inputBytes.getDouble(ipr);
			var cr = inputBytes.getDouble(ipr + 8);
			var gr = inputBytes.getDouble(ipr + 16);
			var tr = inputBytes.getDouble(ipr + 24);
			var op = block * acgtBlockSize;
			downsampleBytes.setDouble(op,(al + ar) * 0.5);
			downsampleBytes.setDouble(op + 8,(cl + cr) * 0.5);
			downsampleBytes.setDouble(op + 16,(gl + gr) * 0.5);
			downsampleBytes.setDouble(op + 24,(tl + tr) * 0.5);
		}
		output.write(downsampleBytes);
		var hrtime1 = process.hrtime();
		var dt = hrtime1[0] + hrtime1[1] / 1e9 - t0;
		var progress = (chunk + 1) / chunksRequired;
		var s1 = Console.logPrefix + ("" + Std.string("<b>" + Math.round(progress * 100) + "%</b> (" + Math.round(bytesToRead / 1e6 / dt * 100) / 100 + " MB/s)"));
		var outputStream1 = 0;
		if(outputStream1 == null) {
			outputStream1 = 0;
		}
		if(s1 == null) {
			s1 = "";
		}
		Console.printFormatted(s1 + "\n",outputStream1);
	}
	input.close();
	output.close();
	return true;
};
Main.convertFastaFile = function(path,outputDirectory,chunkSize_bytes) {
	if(chunkSize_bytes == null) {
		chunkSize_bytes = 10000000;
	}
	var s = Console.logPrefix + ("" + Std.string("<cyan>Reading \"<b>" + path + "</b>\"</cyan>"));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var currentOutputBuffer = null;
	var generatedFilePaths = [];
	var skipSequence = false;
	var returnSequence = true;
	var onFastaSequenceStart = function(name) {
		skipSequence = false;
		returnSequence = true;
		if(Main.sequenceNameFilter != null) {
			if(!Main.sequenceNameFilter.match(name)) {
				var s = Console.warnPrefix + ("" + Std.string("Skipping \"<b>" + name + "</b>\" because it was not included in filter"));
				var outputStream = 1;
				if(outputStream == null) {
					outputStream = 0;
				}
				if(s == null) {
					s = "";
				}
				Console.printFormatted(s + "\n",outputStream);
				skipSequence = true;
				returnSequence = false;
				return;
			}
		}
		var s = Console.logPrefix + ("" + Std.string("Started sequence \"<b>" + name + "</b>\""));
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
		var filename = Main.convertFastaSequenceName(name);
		sys_FileSystem.createDirectory(outputDirectory);
		var path = haxe_io_Path.join([outputDirectory,filename]);
		if(returnSequence) {
			generatedFilePaths.push(path);
		}
		if(sys_FileSystem.exists(path)) {
			var s = Console.warnPrefix + ("" + Std.string("Skipping \"<b>" + path + "</b>\" because file already exists"));
			var outputStream = 1;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
			skipSequence = true;
			return;
		}
		if(currentOutputBuffer != null) {
			currentOutputBuffer.close();
		}
		currentOutputBuffer = new sys_io_FileOutput(js_node_Fs.openSync(path,"w"));
	};
	var onFastaSequenceChunk = function(sequenceChunk) {
		if(skipSequence) {
			return;
		}
		var acgtBlockSize = 32;
		var buffer = new haxe_io_Bytes(new ArrayBuffer(sequenceChunk.totlen * acgtBlockSize));
		var bufferBlockPos = 0;
		currentOutputBuffer.prepare(buffer.length);
		var unknownMap = new haxe_ds_StringMap();
		var hasUnknownCharacters = false;
		var _g = 0;
		var _g1 = sequenceChunk.totlen;
		while(_g < _g1) {
			var i = _g++;
			var charCode = sequenceChunk.readByte();
			switch(charCode) {
			case 10:
				break;
			case 45:
				var pos = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos,0);
				buffer.setDouble(pos + 8,0);
				buffer.setDouble(pos + 16,0);
				buffer.setDouble(pos + 24,0);
				++bufferBlockPos;
				break;
			case 65:case 97:
				var pos1 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos1,1);
				buffer.setDouble(pos1 + 8,0);
				buffer.setDouble(pos1 + 16,0);
				buffer.setDouble(pos1 + 24,0);
				++bufferBlockPos;
				break;
			case 67:case 99:
				var pos2 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos2,0);
				buffer.setDouble(pos2 + 8,1);
				buffer.setDouble(pos2 + 16,0);
				buffer.setDouble(pos2 + 24,0);
				++bufferBlockPos;
				break;
			case 71:case 103:
				var pos3 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos3,0);
				buffer.setDouble(pos3 + 8,0);
				buffer.setDouble(pos3 + 16,1);
				buffer.setDouble(pos3 + 24,0);
				++bufferBlockPos;
				break;
			case 72:case 104:
				var pos4 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos4,0.333333333333333315);
				buffer.setDouble(pos4 + 8,0.333333333333333315);
				buffer.setDouble(pos4 + 16,0);
				buffer.setDouble(pos4 + 24,0.333333333333333315);
				++bufferBlockPos;
				break;
			case 75:case 107:
				var pos5 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos5,0);
				buffer.setDouble(pos5 + 8,0);
				buffer.setDouble(pos5 + 16,0.5);
				buffer.setDouble(pos5 + 24,0.5);
				++bufferBlockPos;
				break;
			case 78:case 110:
				var pos6 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos6,0.25);
				buffer.setDouble(pos6 + 8,0.25);
				buffer.setDouble(pos6 + 16,0.25);
				buffer.setDouble(pos6 + 24,0.25);
				++bufferBlockPos;
				break;
			case 89:case 121:
				var pos7 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos7,0);
				buffer.setDouble(pos7 + 8,0.5);
				buffer.setDouble(pos7 + 16,0);
				buffer.setDouble(pos7 + 24,0.5);
				++bufferBlockPos;
				break;
			case 66:case 98:
				var pos8 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos8,0);
				buffer.setDouble(pos8 + 8,0.333333333333333315);
				buffer.setDouble(pos8 + 16,0.333333333333333315);
				buffer.setDouble(pos8 + 24,0.333333333333333315);
				++bufferBlockPos;
				break;
			case 68:case 100:
				var pos9 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos9,0.333333333333333315);
				buffer.setDouble(pos9 + 8,0);
				buffer.setDouble(pos9 + 16,0.333333333333333315);
				buffer.setDouble(pos9 + 24,0.333333333333333315);
				++bufferBlockPos;
				break;
			case 77:case 109:
				var pos10 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos10,0.5);
				buffer.setDouble(pos10 + 8,0.5);
				buffer.setDouble(pos10 + 16,0);
				buffer.setDouble(pos10 + 24,0);
				++bufferBlockPos;
				break;
			case 82:case 114:
				var pos11 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos11,0.5);
				buffer.setDouble(pos11 + 8,0);
				buffer.setDouble(pos11 + 16,0.5);
				buffer.setDouble(pos11 + 24,0);
				++bufferBlockPos;
				break;
			case 83:case 115:
				var pos12 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos12,0);
				buffer.setDouble(pos12 + 8,0.5);
				buffer.setDouble(pos12 + 16,0.5);
				buffer.setDouble(pos12 + 24,0);
				++bufferBlockPos;
				break;
			case 84:case 116:
				var pos13 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos13,0);
				buffer.setDouble(pos13 + 8,0);
				buffer.setDouble(pos13 + 16,0);
				buffer.setDouble(pos13 + 24,1);
				++bufferBlockPos;
				break;
			case 85:case 117:
				var pos14 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos14,0);
				buffer.setDouble(pos14 + 8,0);
				buffer.setDouble(pos14 + 16,0);
				buffer.setDouble(pos14 + 24,1);
				++bufferBlockPos;
				break;
			case 86:case 118:
				var pos15 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos15,0.333333333333333315);
				buffer.setDouble(pos15 + 8,0.333333333333333315);
				buffer.setDouble(pos15 + 16,0.333333333333333315);
				buffer.setDouble(pos15 + 24,0);
				++bufferBlockPos;
				break;
			case 87:case 119:
				var pos16 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos16,0.5);
				buffer.setDouble(pos16 + 8,0);
				buffer.setDouble(pos16 + 16,0);
				buffer.setDouble(pos16 + 24,0.5);
				++bufferBlockPos;
				break;
			default:
				hasUnknownCharacters = true;
				var char = String.fromCodePoint(charCode);
				var count = unknownMap.h[char];
				if(count == null) {
					count = 0;
				}
				unknownMap.h[char] = count + 1;
				var pos17 = bufferBlockPos * acgtBlockSize;
				buffer.setDouble(pos17,0);
				buffer.setDouble(pos17 + 8,0);
				buffer.setDouble(pos17 + 16,0);
				buffer.setDouble(pos17 + 24,0);
				++bufferBlockPos;
			}
		}
		sequenceChunk.close();
		currentOutputBuffer.writeFullBytes(buffer,0,bufferBlockPos * acgtBlockSize);
		if(hasUnknownCharacters) {
			var s = Console.errorPrefix + ("Unknown characters" + Console.argSeparator + Std.string(unknownMap));
			var outputStream = 2;
			if(outputStream == null) {
				outputStream = 0;
			}
			if(s == null) {
				s = "";
			}
			Console.printFormatted(s + "\n",outputStream);
		}
	};
	var fastaParser = new FastaParser(onFastaSequenceStart,onFastaSequenceChunk);
	var input = new sys_io_FileInput(js_node_Fs.openSync(path,"r"));
	var length_bytes = js_node_Fs.statSync(path).size;
	var chunksRequired = Math.ceil(length_bytes / chunkSize_bytes);
	var s = Console.logPrefix + ("" + Std.string("" + chunksRequired + " chunks required"));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	var hrtime = process.hrtime();
	var tStart = hrtime[0] + hrtime[1] / 1e9;
	var _g = 0;
	var _g1 = chunksRequired;
	while(_g < _g1) {
		var chunk = _g++;
		var hrtime = process.hrtime();
		var t0 = hrtime[0] + hrtime[1] / 1e9;
		var bytesRemaining = length_bytes - chunk * chunkSize_bytes;
		var bytesToRead = Math.min(bytesRemaining,chunkSize_bytes) | 0;
		fastaParser.processChunk(input.read(bytesToRead));
		var hrtime1 = process.hrtime();
		var dt = hrtime1[0] + hrtime1[1] / 1e9 - t0;
		var progress = (chunk + 1) / chunksRequired;
		var s = Console.logPrefix + ("" + Std.string("<b>" + Math.round(progress * 100) + "%</b> (" + Math.round(bytesToRead / 1e6 / dt * 100) / 100 + " MB/s)"));
		var outputStream = 0;
		if(outputStream == null) {
			outputStream = 0;
		}
		if(s == null) {
			s = "";
		}
		Console.printFormatted(s + "\n",outputStream);
	}
	input.close();
	fastaParser.done();
	var hrtime = process.hrtime();
	var dt = hrtime[0] + hrtime[1] / 1e9 - tStart;
	var s = Console.logPrefix + ("" + Std.string("Converting FASTA file took " + Math.round(dt * 10) / 10 + "s (" + Math.round(length_bytes / 1e6 / dt * 100) / 100 + " MB/s)"));
	var outputStream = 0;
	if(outputStream == null) {
		outputStream = 0;
	}
	if(s == null) {
		s = "";
	}
	Console.printFormatted(s + "\n",outputStream);
	if(currentOutputBuffer != null) {
		currentOutputBuffer.close();
	}
	return generatedFilePaths;
};
var FastaParser = function(onSequenceStarted,onSequenceChunk) {
	this.headerBuffer = "";
	this.parseMode = 0;
	this.onSequenceStarted = onSequenceStarted;
	this.onSequenceChunk = onSequenceChunk;
};
FastaParser.__name__ = true;
FastaParser.prototype = {
	processChunk: function(bytes) {
		var sequenceStart = 0;
		var _g = 0;
		var _g1 = bytes.length;
		while(_g < _g1) {
			var i = _g++;
			var byte = bytes.b[i];
			switch(this.parseMode) {
			case 1:
				if(byte == 10) {
					this.onSequenceStarted(this.headerBuffer);
					this.parseMode = 2;
					sequenceStart = i + 1;
				} else {
					this.headerBuffer += String.fromCodePoint(byte);
				}
				break;
			case 0:case 2:
				if(byte == 62) {
					if(this.parseMode == 2) {
						var sequenceLength = i - sequenceStart;
						this.onSequenceChunk(new haxe_io_BytesInput(bytes,sequenceStart,sequenceLength));
					}
					this.headerBuffer = "";
					this.parseMode = 1;
				}
				break;
			}
		}
		if(this.parseMode == 2) {
			this.onSequenceChunk(new haxe_io_BytesInput(bytes,sequenceStart));
		}
	}
	,done: function() {
	}
};
Math.__name__ = true;
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Output.hx", lineNumber : 47, className : "haxe.io.Output", methodName : "writeByte"});
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,close: function() {
	}
	,write: function(s) {
		var l = s.length;
		var p = 0;
		while(l > 0) {
			var k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,prepare: function(nbytes) {
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
};
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
});
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Input.hx", lineNumber : 53, className : "haxe.io.Input", methodName : "readByte"});
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return len - k;
	}
	,close: function() {
	}
	,read: function(nbytes) {
		var s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
};
var UInt = {};
UInt.gt = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a > b;
	}
};
UInt.gte = function(a,b) {
	var aNeg = a < 0;
	var bNeg = b < 0;
	if(aNeg != bNeg) {
		return aNeg;
	} else {
		return a >= b;
	}
};
UInt.toFloat = function(this1) {
	var int = this1;
	if(int < 0) {
		return 4294967296.0 + int;
	} else {
		return int + 0.0;
	}
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,toString: function() {
		return this.get_message();
	}
	,get_message: function() {
		return this.message;
	}
	,get_native: function() {
		return this.__nativeException;
	}
});
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
});
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
var haxe_exceptions_PosException = function(message,previous,pos) {
	haxe_Exception.call(this,message,previous);
	if(pos == null) {
		this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
	} else {
		this.posInfos = pos;
	}
};
haxe_exceptions_PosException.__name__ = true;
haxe_exceptions_PosException.__super__ = haxe_Exception;
haxe_exceptions_PosException.prototype = $extend(haxe_Exception.prototype,{
	toString: function() {
		return "" + haxe_Exception.prototype.toString.call(this) + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
});
var haxe_exceptions_NotImplementedException = function(message,previous,pos) {
	if(message == null) {
		message = "Not implemented";
	}
	haxe_exceptions_PosException.call(this,message,previous,pos);
};
haxe_exceptions_NotImplementedException.__name__ = true;
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
haxe_exceptions_NotImplementedException.prototype = $extend(haxe_exceptions_PosException.prototype,{
});
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	getDouble: function(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat64(pos,true);
	}
	,setDouble: function(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat64(pos,v,true);
	}
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
haxe_io_BytesInput.__name__ = true;
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		if(this.len == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.withoutExtension = function(path) {
	var s = new haxe_io_Path(path);
	s.ext = null;
	return s.toString();
};
haxe_io_Path.withoutDirectory = function(path) {
	var s = new haxe_io_Path(path);
	s.dir = null;
	return s.toString();
};
haxe_io_Path.join = function(paths) {
	var _g = [];
	var _g1 = 0;
	var _g2 = paths;
	while(_g1 < _g2.length) {
		var v = _g2[_g1];
		++_g1;
		if(v != null && v != "") {
			_g.push(v);
		}
	}
	var paths = _g;
	if(paths.length == 0) {
		return "";
	}
	var path = paths[0];
	var _g = 1;
	var _g1 = paths.length;
	while(_g < _g1) {
		var i = _g++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2_offset = 0;
	var _g2_s = tmp;
	while(_g2_offset < _g2_s.length) {
		var s = _g2_s;
		var index = _g2_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g2_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var sys_FileSystem = function() { };
sys_FileSystem.__name__ = true;
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _g ) {
		return false;
	}
};
sys_FileSystem.createDirectory = function(path) {
	try {
		js_node_Fs.mkdirSync(path);
	} catch( _g ) {
		var e = haxe_Exception.caught(_g).unwrap();
		if(e.code == "ENOENT") {
			sys_FileSystem.createDirectory(js_node_Path.dirname(path));
			js_node_Fs.mkdirSync(path);
		} else {
			var stat;
			try {
				stat = js_node_Fs.statSync(path);
			} catch( _g1 ) {
				throw e;
			}
			if(!stat.isDirectory()) {
				throw e;
			}
		}
	}
};
var sys_io_FileInput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileInput.__name__ = true;
sys_io_FileInput.__super__ = haxe_io_Input;
sys_io_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = js_node_buffer_Buffer.alloc(1);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,0,1,this.pos);
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
		if(bytesRead == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.pos++;
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,pos,len,this.pos);
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
		if(bytesRead == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.pos += bytesRead;
		return bytesRead;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
});
var sys_io_FileOutput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileOutput.__name__ = true;
sys_io_FileOutput.__super__ = haxe_io_Output;
sys_io_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(b) {
		var buf = js_node_buffer_Buffer.alloc(1);
		buf[0] = b;
		js_node_Fs.writeSync(this.fd,buf,0,1,this.pos);
		this.pos++;
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		var wrote = js_node_Fs.writeSync(this.fd,buf,pos,len,this.pos);
		this.pos += wrote;
		return wrote;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
});
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
js_Boot.__toStr = ({ }).toString;
Console.formatMode = Console.determineConsoleFormatMode();
Console.logPrefix = "<b,gray>><//> ";
Console.warnPrefix = "<b,yellow>><//> ";
Console.errorPrefix = "<b,red>></b> ";
Console.successPrefix = "<b,light_green>><//> ";
Console.argSeparator = " ";
Console.unicodeCompatibilityMode = Sys.systemName() == "Windows" ? 1 : 0;
Console.unicodeCompatibilityEnabled = false;
Console.formatTagPattern = new EReg("(\\\\)?<(/)?([^><{}\\s]*|{[^}<>]*})>","g");
Main.main();
})({});
